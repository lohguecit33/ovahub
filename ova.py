import os
import time
import json
import subprocess
import xml.etree.ElementTree as ET
import sys
import shutil
from datetime import datetime
from collections import deque

# =========================
# GLOBAL
# =========================
CONFIG_FILE = "config.json"
PACKAGES_FILE = "packages.json"
monitor_active = False

# Account state tracking (seperti PC version)
ACCOUNT_STATE = {}  # pkg -> {launch_time, json_start_time, json_active, last_status}

# Log system - rolling 5 baris terakhir
LOG_BUFFER = deque(maxlen=5)
LAST_DISPLAY_STATUS = {}  # pkg -> status terakhir yang ditampilkan

# =========================
# BASIC UTILS
# =========================
def run_root_cmd(cmd):
    try:
        r = subprocess.run(
            ["su", "-c", cmd],
            capture_output=True,
            text=True,
            timeout=10
        )
        return r.stdout.strip() if r.returncode == 0 else ""
    except subprocess.TimeoutExpired:
        add_log("Command timeout")
        return ""
    except FileNotFoundError:
        add_log("ERROR: su not found")
        return ""
    except Exception as e:
        add_log(f"Command error: {e}")
        return ""

# =========================
# CPU & RAM MONITORING
# =========================
def get_cpu_count():
    try:
        cpu_count = os.cpu_count()
        if cpu_count:
            return cpu_count
        
        with open('/proc/cpuinfo', 'r') as f:
            cpu_count = len([line for line in f if line.startswith('processor')])
            if cpu_count > 0:
                return cpu_count
        
        return 4
    except:
        return 4


def get_ram_info():
    try:
        with open('/proc/meminfo', 'r') as f:
            lines = f.readlines()
        
        mem_total_kb = 0
        mem_free_kb = 0
        buffers_kb = 0
        cached_kb = 0
        
        for line in lines:
            if line.startswith('MemTotal:'):
                mem_total_kb = int(line.split()[1])
            elif line.startswith('MemFree:'):
                mem_free_kb = int(line.split()[1])
            elif line.startswith('Buffers:'):
                buffers_kb = int(line.split()[1])
            elif line.startswith('Cached:'):
                cached_kb = int(line.split()[1])
        
        mem_used_kb = mem_total_kb - mem_free_kb - buffers_kb - cached_kb
        
        total_mb = mem_total_kb / 1024
        used_mb = mem_used_kb / 1024
        
        percent = (used_mb / total_mb) * 100 if total_mb > 0 else 0
        
        return {
            "total_mb": round(total_mb,2),
            "used_mb": round(used_mb,2),
            "percent": round(percent,1)
        }
    except:
        return None


def get_package_cpu_usage(package_name):
    try:
        pid_str = run_root_cmd(f"pidof {package_name}")
        if not pid_str:
            return 0.0
        
        pids = pid_str.split()
        total_cpu = 0.0
        
        for pid in pids:
            stat1 = run_root_cmd(f"cat /proc/{pid}/stat 2>/dev/null")
            uptime1 = run_root_cmd("cat /proc/uptime 2>/dev/null")
            if not stat1 or not uptime1:
                continue
            
            parts1 = stat1.split()
            utime1 = int(parts1[13])
            stime1 = int(parts1[14])
            uptime_sec1 = float(uptime1.split()[0])
            
            time.sleep(0.2)
            
            stat2 = run_root_cmd(f"cat /proc/{pid}/stat 2>/dev/null")
            uptime2 = run_root_cmd("cat /proc/uptime 2>/dev/null")
            if not stat2 or not uptime2:
                continue
            
            parts2 = stat2.split()
            utime2 = int(parts2[13])
            stime2 = int(parts2[14])
            uptime_sec2 = float(uptime2.split()[0])
            
            proc_time = ((utime2+stime2)-(utime1+stime1)) / 100.0
            elapsed = uptime_sec2 - uptime_sec1
            
            if elapsed > 0:
                cpu = (proc_time / elapsed) * 100.0
                cpu /= get_cpu_count()
                total_cpu += min(cpu,100)
        
        return round(min(total_cpu,100),1)
    except:
        return 0.0


def get_package_ram_usage(package_name):
    try:
        pid_str = run_root_cmd(f"pidof {package_name}")
        if not pid_str:
            return None
        
        total_rss_kb = 0
        for pid in pid_str.split():
            status_content = run_root_cmd(f"cat /proc/{pid}/status 2>/dev/null")
            if not status_content:
                continue
            
            for line in status_content.splitlines():
                if line.startswith("VmRSS:"):
                    total_rss_kb += int(line.split()[1])
                    break
        
        if total_rss_kb == 0:
            return None
        
        rss_mb = total_rss_kb / 1024.0
        
        ram_info = get_ram_info()
        percent = (rss_mb / ram_info["total_mb"] * 100) if ram_info else 0
        
        return {
            "used_mb": round(rss_mb,2),
            "percent": round(percent,2)
        }
    except:
        return None


def get_all_packages_stats(pkgs):
    stats = {}
    
    for pkg, info in pkgs.items():
        cpu = get_package_cpu_usage(pkg)
        ram = get_package_ram_usage(pkg)
        
        stats[pkg] = {
            "username": info["username"],
            "cpu": cpu,
            "ram_mb": ram["used_mb"] if ram else 0,
            "ram_percent": ram["percent"] if ram else 0
        }
    
    return stats


# =========================
# DISCORD WEBHOOK
# =========================
def send_discord_webhook(webhook_url, title, message, color=None):
    """Kirim pesan ke Discord webhook - IMPROVED VERSION"""
    if not webhook_url or webhook_url == "":
        return False
    
    try:
        color = color or 16711680  # Red default
        
        # Build JSON payload dengan escaping yang benar
        payload = {
            "embeds": [{
                "title": str(title),
                "description": str(message),
                "color": int(color),
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
            }]
        }
        
        # Convert ke JSON string
        payload_str = json.dumps(payload)
        
        # Escape single quotes untuk shell command
        payload_escaped = payload_str.replace("'", "'\"'\"'")
        
        # Build curl command
        cmd = f"curl -s -X POST -H 'Content-Type: application/json' -d '{payload_escaped}' '{webhook_url}'"
        
        # Execute command
        result = os.system(cmd)
        
        return result == 0
    except Exception as e:
        log(f"Webhook error: {e}")
        return False


def build_webhook_status_message(pkgs, cfg):
    stats = get_all_packages_stats(pkgs)
    ram_info = get_ram_info()
    cpu_cores = get_cpu_count()

    # Hitung total CPU (dibatasi max 100%)
    total_cpu = round(min(sum(s["cpu"] for s in stats.values()), 100.0), 1)

    # RAM persen system
    ram_percent = ram_info["percent"] if ram_info else 0

    # Hitung running
    running_count = 0
    total_count = len(pkgs)

    lines = []

    # SYSTEM
    lines.append("SYSTEM")
    lines.append(f"CPU {total_cpu}% / {cpu_cores} cores")
    lines.append(f"RAM {ram_percent}%")
    lines.append("")

    # ACCOUNTS
    for pkg, info in pkgs.items():
        status = determine_account_status(pkg, info, cfg)
        if status in ("in_game", "waiting"):
            running_count += 1

    lines.append("ACCOUNTS")
    lines.append(f"{running_count} Running / {total_count} Total")
    lines.append("")

    # DETAIL
    lines.append("DETAIL")

    for pkg, info in pkgs.items():
        username = info["username"]
        status = determine_account_status(pkg, info, cfg).upper()

        cpu = stats[pkg]["cpu"]
        ram_mb = stats[pkg]["ram_mb"]

        lines.append(f"{username:<10} CPU {cpu:<4}% RAM {int(ram_mb):<4}MB  {status}")

    return "\n".join(lines)


def clear_screen():
    """Clear screen dengan ANSI escape code"""
    print("\033[2J\033[H", end='')
    sys.stdout.flush()

def add_log(msg):
    """Tambah log ke buffer (max 5 baris)"""
    timestamp = time.strftime('%H:%M:%S')
    LOG_BUFFER.append(f"[{timestamp}] {msg}")

# =========================
# CONFIG
# =========================
def load_config():
    default = {
        "game_id": "",
        "check_interval": 10,
        "first_check": 3,  # Grace period dalam menit (seperti PC version)
        "workspace_check_interval": 5,
        "json_suffix": "_checkyum.json",
        "startup_delay": 8,
        "restart_delay": 3,
        "autoexec_enabled": True,
        "webhook_url": "",
        "webhook_enabled": True,
        "webhook_interval": 10,
        "restart_interval": 0
    }
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE) as f:
                loaded = json.load(f)
                default.update(loaded)
        except Exception as e:
            add_log(f"Config load error: {e}")
    return default

def save_config(cfg):
    try:
        with open(CONFIG_FILE, "w") as f:
            json.dump(cfg, f, indent=2)
        add_log("Config saved")
    except Exception as e:
        add_log(f"Config save error: {e}")


# =========================
# PACKAGE DETECTION
# =========================
def get_roblox_packages():
    out = run_root_cmd("pm list packages | grep com.roblox")
    pkgs = []
    for line in out.splitlines():
        if line.startswith("package:"):
            pkgs.append(line.split(":")[1])
    return pkgs

def get_username_from_prefs(package):
    prefs = f"/data/data/{package}/shared_prefs/prefs.xml"
    xml = run_root_cmd(f"cat {prefs}")
    if not xml:
        return None
    try:
        root = ET.fromstring(xml)
        for c in root:
            if c.tag == "string" and c.attrib.get("name") == "username":
                return c.text.strip() if c.text else None
    except Exception as e:
        add_log(f"Prefs parse error {package}: {e}")
    return None

def auto_detect_and_save_packages():
    clear_screen()
    print("AUTO DETECT ROBLOX PACKAGES\n")
    pkgs = get_roblox_packages()
    saved = {}

    for pkg in pkgs:
        print(f"Checking {pkg}...", end=" ")
        user = get_username_from_prefs(pkg)
        if user:
            package_info = {
                "username": user,
                "package_name": pkg,
                "workspace_dir": f"/storage/emulated/0/Android/data/{pkg}/files/gloop/external/Workspace",
                "autoexec_dir": f"/storage/emulated/0/Android/data/{pkg}/files/gloop/external/Autoexecute",
                "cache_dir": f"/storage/emulated/0/Android/data/{pkg}/files/gloop/external/Internals/Cache",
                "license_path": f"/storage/emulated/0/Android/data/{pkg}/files/gloop/external/Internals/Cache"
            }
            saved[pkg] = package_info
            print(f"{user} ‚úì")
        else:
            print("SKIP")

    if saved:
        with open(PACKAGES_FILE, "w") as f:
            json.dump(saved, f, indent=2)
        print(f"\nSaved {len(saved)} packages")
    else:
        print("\nNo valid packages")

    input("\nEnter...")

def load_packages():
    if not os.path.exists(PACKAGES_FILE):
        return {}
    try:
        with open(PACKAGES_FILE) as f:
            return json.load(f)
    except:
        return {}

# =========================
# CACHE FOLDER MANAGEMENT
# =========================
def find_cache_dir(package_name):
    """Cari folder Cache untuk package tertentu"""
    possible_paths = [
        f"/storage/emulated/0/Android/data/{package_name}/files/gloop/external/Internals/Cache",
        f"/sdcard/Android/data/{package_name}/files/gloop/external/Internals/Cache",
    ]
    
    for cache_dir in possible_paths:
        if not os.path.isdir(cache_dir):
            continue
        
        try:
            files = os.listdir(cache_dir)
            if files:
                return cache_dir
        except:
            pass
    
    return None

def copy_all_cache_files(source_cache_dir, dest_cache_dir, use_root=False):
    """
    Copy semua file dari folder Cache source ke destination
    
    Args:
        source_cache_dir: Path folder Cache sumber
        dest_cache_dir: Path folder Cache tujuan
        use_root: Gunakan root command jika True
    
    Returns:
        tuple: (success_count, failed_count, error_msg)
    """
    success = 0
    failed = 0
    error_msg = ""
    
    try:
        # Pastikan source folder ada
        if not os.path.isdir(source_cache_dir):
            return 0, 0, f"Source folder tidak ditemukan: {source_cache_dir}"
        
        # Buat destination folder jika belum ada
        if use_root:
            run_root_cmd(f"mkdir -p '{dest_cache_dir}'")
        else:
            os.makedirs(dest_cache_dir, exist_ok=True)
        
        # List semua file di source
        try:
            source_files = os.listdir(source_cache_dir)
        except PermissionError:
            # Jika tidak bisa list dengan Python, coba dengan root
            if use_root:
                file_list = run_root_cmd(f"ls '{source_cache_dir}'")
                source_files = file_list.split('\n') if file_list else []
            else:
                return 0, 0, "Permission denied - coba gunakan root mode"
        
        if not source_files:
            return 0, 0, "Source folder kosong"
        
        # Copy setiap file
        for filename in source_files:
            if not filename.strip():
                continue
                
            source_file = os.path.join(source_cache_dir, filename)
            dest_file = os.path.join(dest_cache_dir, filename)
            
            try:
                if use_root:
                    result = run_root_cmd(f"cp '{source_file}' '{dest_file}'")
                    if result == "":  # Empty string means success
                        success += 1
                    else:
                        failed += 1
                        error_msg += f"Failed to copy {filename}; "
                else:
                    shutil.copy2(source_file, dest_file)
                    success += 1
            except Exception as e:
                failed += 1
                error_msg += f"Error copying {filename}: {str(e)}; "
        
        return success, failed, error_msg
    
    except Exception as e:
        return 0, 0, f"General error: {str(e)}"

def copy_license_to_all_packages():
    """Menu untuk copy license ke semua package"""
    clear_screen()
    print("=" * 70)
    print("üóÇÔ∏è COPY CACHE FILES TO ALL PACKAGES")
    print("=" * 70)
    
    pkgs = load_packages()
    if not pkgs:
        add_log("No packages found")
        input("\nPress ENTER...")
        return
    
    # Cari source package yang punya cache
    source_pkg = None
    source_cache_dir = None
    
    print("\nüìã Available packages with cache:")
    available = []
    for i, (pkg, info) in enumerate(pkgs.items(), 1):
        cache_dir = find_cache_dir(pkg)
        if cache_dir:
            available.append((pkg, info, cache_dir))
            print(f"  {i}. {info['username']} (Package: {pkg})")
    
    if not available:
        add_log("‚ùå No packages with cache files found!")
        input("\nPress ENTER...")
        return
    
    # Pilih source
    choice = input(f"\nüìå Select source package (1-{len(available)}) or Enter for first: ").strip()
    
    if choice == "":
        source_pkg, source_info, source_cache_dir = available[0]
    else:
        try:
            idx = int(choice) - 1
            if 0 <= idx < len(available):
                source_pkg, source_info, source_cache_dir = available[idx]
            else:
                add_log("Invalid choice")
                input("\nPress ENTER...")
                return
        except ValueError:
            add_log("Invalid input")
            input("\nPress ENTER...")
            return
    
    add_log(f"\n‚úÖ Source: {source_info['username']} ({source_pkg})")
    add_log(f"üìÇ Source cache: {source_cache_dir}")
    
    # Tampilkan file yang akan di-copy
    try:
        files = os.listdir(source_cache_dir)
        add_log(f"üìÑ Files to copy: {len(files)}")
        for f in files[:5]:  # Show first 5
            add_log(f"  - {f}")
        if len(files) > 5:
            add_log(f"  ... and {len(files) - 5} more files")
    except Exception as e:
        add_log(f"Error listing files: {e}")
    
    confirm = input("\n‚ö†Ô∏è Copy to ALL other packages? (y/n): ").strip().lower()
    if confirm != 'y':
        add_log("Cancelled")
        input("\nPress ENTER...")
        return
    
    # Tanya mode
    mode = input("Use root mode? (y/n, default=n): ").strip().lower()
    use_root = (mode == 'y')
    
    print("\n" + "=" * 70)
    add_log("Starting copy process...")
    print("=" * 70)
    
    total_success = 0
    total_failed = 0
    
    for pkg, info in pkgs.items():
        if pkg == source_pkg:
            continue
        
        username = info['username']
        dest_cache_dir = find_cache_dir(pkg)
        
        if not dest_cache_dir:
            # Coba buat folder
            dest_cache_dir = f"/storage/emulated/0/Android/data/{pkg}/files/gloop/external/Internals/Cache"
            if use_root:
                run_root_cmd(f"mkdir -p '{dest_cache_dir}'")
            else:
                try:
                    os.makedirs(dest_cache_dir, exist_ok=True)
                except:
                    pass
        
        add_log(f"\nüì¶ Copying to: {username}")
        success, failed, error = copy_all_cache_files(source_cache_dir, dest_cache_dir, use_root)
        
        if success > 0:
            add_log(f"  ‚úÖ Success: {success} files")
            total_success += success
        if failed > 0:
            add_log(f"  ‚ùå Failed: {failed} files")
            total_failed += failed
        if error:
            add_log(f"  ‚ö†Ô∏è Errors: {error[:100]}")
    
    print("\n" + "=" * 70)
    add_log(f"üìä RESULTS:")
    add_log(f"  ‚úÖ Total success: {total_success} files")
    add_log(f"  ‚ùå Total failed: {total_failed} files")
    print("=" * 70)
    
    input("\nPress ENTER...")

def view_license_status():
    """Lihat status cache untuk semua package"""
    clear_screen()
    print("=" * 70)
    print("üìä CACHE FOLDER STATUS")
    print("=" * 70)
    
    pkgs = load_packages()
    if not pkgs:
        add_log("No packages found")
        input("\nPress ENTER...")
        return
    
    print(f"\n{'No.':<4} {'Username':<20} {'Cache Status':<15} {'File Count':<12}")
    print("-" * 70)
    
    for i, (pkg, info) in enumerate(pkgs.items(), 1):
        username = info['username']
        cache_dir = find_cache_dir(pkg)
        
        if cache_dir:
            try:
                files = os.listdir(cache_dir)
                file_count = len(files)
                status = "‚úÖ Found"
                count_str = str(file_count)
            except:
                status = "‚ö†Ô∏è Error"
                count_str = "N/A"
        else:
            status = "‚ùå Not Found"
            count_str = "0"
        
        print(f"{i:<4} {username:<20} {status:<15} {count_str:<12}")
    
    print("=" * 70)
    input("\nPress ENTER...")

# =========================
# SCRIPT MANAGEMENT
# =========================
def list_executor_scripts(package_info):
    """Mendapatkan daftar script untuk paket tertentu"""
    autoexec_dir = package_info.get("autoexec_dir", "")
    
    if not autoexec_dir or not os.path.exists(autoexec_dir):
        return []
    
    try:
        return [
            f for f in os.listdir(autoexec_dir)
            if f.endswith((".lua", ".txt"))
        ]
    except:
        return []

def add_script_to_all_packages():
    """Menambahkan script ke semua paket"""
    clear_screen()
    print("=" * 70)
    print("üìù ADD SCRIPT TO ALL PACKAGES")
    print("=" * 70)
    
    pkgs = load_packages()
    if not pkgs:
        add_log("No packages found")
        input("\nPress ENTER...")
        return
    
    print(f"\nFound {len(pkgs)} packages:")
    for i, (pkg, info) in enumerate(pkgs.items(), 1):
        print(f"  {i}. {info['username']}")
    
    print("\n" + "-" * 70)
    print("Paste script content (press ENTER twice to finish):")
    
    lines = []
    empty_count = 0
    
    while True:
        try:
            line = input()
        except (EOFError, KeyboardInterrupt):
            print()
            break
        
        if line == "":
            empty_count += 1
            if empty_count >= 2:
                break
        else:
            empty_count = 0
            lines.append(line)
    
    script_content = "\n".join(lines).strip()
    
    if not script_content:
        add_log("Empty script, cancelled")
        input("\nPress ENTER...")
        return
    
    script_name = input("\nüìå Script name (without .lua): ").strip()
    if not script_name:
        add_log("Invalid script name")
        input("\nPress ENTER...")
        return
    
    if not script_name.endswith(".lua"):
        script_name += ".lua"
    
    print("\n" + "=" * 70)
    add_log("Adding script to all packages...")
    print("=" * 70)
    
    success_count = 0
    failed_count = 0
    
    for pkg, info in pkgs.items():
        autoexec_dir = info.get("autoexec_dir", "")
        
        if not autoexec_dir:
            add_log(f"‚ùå {info['username']}: No autoexec dir")
            failed_count += 1
            continue
        
        # Buat folder jika belum ada
        if not os.path.exists(autoexec_dir):
            try:
                os.makedirs(autoexec_dir, exist_ok=True)
            except Exception as e:
                add_log(f"‚ùå {info['username']}: Can't create dir - {e}")
                failed_count += 1
                continue
        
        # Tulis script
        script_path = os.path.join(autoexec_dir, script_name)
        try:
            with open(script_path, 'w') as f:
                f.write(script_content)
            add_log(f"‚úÖ {info['username']}")
            success_count += 1
        except Exception as e:
            add_log(f"‚ùå {info['username']}: {e}")
            failed_count += 1
    
    print("\n" + "=" * 70)
    add_log(f"üìä RESULTS: {success_count} success, {failed_count} failed")
    print("=" * 70)
    input("\nPress ENTER...")

def delete_script_from_all_packages():
    """Hapus script dari semua package"""
    clear_screen()
    print("=" * 70)
    print("üóëÔ∏è DELETE SCRIPT FROM ALL PACKAGES")
    print("=" * 70)
    
    pkgs = load_packages()
    if not pkgs:
        add_log("No packages found")
        input("\nPress ENTER...")
        return
    
    # Tampilkan script yang ada
    print("\nüìã Available scripts:")
    all_scripts = set()
    
    for pkg, info in pkgs.items():
        scripts = list_executor_scripts(info)
        all_scripts.update(scripts)
    
    if not all_scripts:
        add_log("No scripts found in any package")
        input("\nPress ENTER...")
        return
    
    for i, script in enumerate(sorted(all_scripts), 1):
        print(f"  {i}. {script}")
    
    # Pilih script
    script_name = input("\nüìå Script name to delete: ").strip()
    if not script_name:
        add_log("Cancelled")
        input("\nPress ENTER...")
        return
    
    confirm = input(f"\n‚ö†Ô∏è Delete '{script_name}' from ALL packages? (y/n): ").strip().lower()
    if confirm != 'y':
        add_log("Cancelled")
        input("\nPress ENTER...")
        return
    
    # Hapus dari semua package
    success_count = 0
    not_found_count = 0
    
    for pkg, info in pkgs.items():
        autoexec_dir = info.get("autoexec_dir", "")
        if not autoexec_dir:
            continue
        
        script_path = os.path.join(autoexec_dir, script_name)
        
        if os.path.exists(script_path):
            try:
                os.remove(script_path)
                add_log(f"‚úÖ {info['username']}")
                success_count += 1
            except Exception as e:
                add_log(f"‚ùå {info['username']}: {e}")
        else:
            not_found_count += 1
    
    print("\n" + "=" * 70)
    add_log(f"üìä RESULTS: {success_count} deleted, {not_found_count} not found")
    print("=" * 70)
    input("\nPress ENTER...")

def view_scripts_all_packages():
    """Lihat semua script di semua package"""
    clear_screen()
    print("=" * 70)
    print("üëÅÔ∏è VIEW SCRIPTS IN ALL PACKAGES")
    print("=" * 70)
    
    pkgs = load_packages()
    if not pkgs:
        add_log("No packages found")
        input("\nPress ENTER...")
        return
    
    for i, (pkg, info) in enumerate(pkgs.items(), 1):
        username = info['username']
        scripts = list_executor_scripts(info)
        
        print(f"\n{i}. {username}")
        if scripts:
            for script in scripts:
                print(f"   üìú {script}")
        else:
            print("   (No scripts)")
    
    print("\n" + "=" * 70)
    input("\nPress ENTER...")

# =========================
# ROBLOX APP CONTROL
# =========================
def is_app_running(package):
    out = run_root_cmd(f"pidof {package}")
    return bool(out.strip())

def start_app(package, game_id):
    intent = f"am start -n {package}/com.roblox.client.ActivityProtocolLaunch -d roblox://placeID={game_id}"
    run_root_cmd(intent)

def stop_app(package):
    run_root_cmd(f"am force-stop {package}")

# =========================
# JSON WORKSPACE MONITORING (seperti PC version)
# =========================
def get_workspace_json_path(package_info, username, cfg):
    """Mendapatkan path workspace JSON"""
    workspace_dir = package_info.get("workspace_dir", 
                     f"/storage/emulated/0/Android/data/com.roblox.client/files/gloop/external/Workspace")
    os.makedirs(workspace_dir, exist_ok=True)
    return f"{workspace_dir}/{username}{cfg['json_suffix']}"

def get_json_time_diff(package_info, username, cfg):
    """
    Mendapatkan selisih waktu sejak JSON terakhir update
    Returns: float (seconds) atau None jika JSON tidak ada
    """
    json_path = get_workspace_json_path(package_info, username, cfg)
    
    if not os.path.exists(json_path):
        return None
    
    try:
        with open(json_path, 'r') as f:
            data = json.load(f)
        
        # Cari field timestamp
        timestamp_field = None
        for field in ["timestamp", "time", "last_update", "updated_at"]:
            if field in data:
                timestamp_field = data[field]
                break
        
        if timestamp_field:
            # Parse timestamp
            if isinstance(timestamp_field, (int, float)):
                json_time = timestamp_field
            elif isinstance(timestamp_field, str):
                # Coba parse ISO format
                if "T" in timestamp_field and "Z" in timestamp_field:
                    dt_str = timestamp_field.replace("Z", "+00:00")
                    dt = datetime.fromisoformat(dt_str)
                    json_time = dt.timestamp()
                else:
                    return None
            else:
                return None
            
            # Hitung selisih dengan waktu sekarang
            current_time = time.time()
            time_diff = current_time - json_time
            return time_diff
        else:
            # Fallback ke modification time
            mtime = os.path.getmtime(json_path)
            return time.time() - mtime
            
    except Exception as e:
        return None

def check_json_running(package_info, username, cfg):
    """
    Check apakah JSON sedang berjalan (< 60 detik seperti PC version)
    """
    time_diff = get_json_time_diff(package_info, username, cfg)
    
    if time_diff is None:
        return False
    
    return time_diff <= 60

def determine_account_status(pkg, package_info, cfg):
    """
    Menentukan status akun berdasarkan logika PC version:
    - offline: Client tidak berjalan
    - waiting: Launch baru, menunggu first check
    - in_game: JSON aktif
    - needs_kill: JSON tidak aktif setelah melewati first check / grace period
    """
    username = package_info["username"]
    
    # Initialize state jika belum ada
    if pkg not in ACCOUNT_STATE:
        ACCOUNT_STATE[pkg] = {
            "launch_time": None,
            "json_start_time": None,
            "json_active": False,
            "last_status": "offline"
        }
    
    acc = ACCOUNT_STATE[pkg]
    
    # 1. Jika client tidak berjalan ‚Üí OFFLINE
    if not is_app_running(pkg):
        # Reset semua timer saat offline
        acc["json_active"] = False
        acc["json_start_time"] = None
        acc["last_status"] = "offline"
        return "offline"
    
    # 2. Client berjalan, cek JSON
    json_running = check_json_running(package_info, username, cfg)
    current_time = time.time()
    first_check_seconds = cfg["first_check"] * 60
    
    # 3. Jika JSON berjalan
    if json_running:
        # Update JSON timer setiap kali JSON aktif (PENTING!)
        acc["json_active"] = True
        acc["json_start_time"] = current_time
        acc["last_status"] = "in_game"
        return "in_game"
    
    # 4. JSON tidak berjalan - cek kondisi
    launch_time = acc.get("launch_time")
    json_active = acc.get("json_active", False)
    json_start_time = acc.get("json_start_time")
    
    # 4a. Jika baru launch, masih dalam grace period ‚Üí WAITING
    if launch_time is not None:
        time_since_launch = current_time - launch_time
        if time_since_launch < first_check_seconds:
            acc["last_status"] = "waiting"
            return "waiting"
    
    # 4b. Jika JSON pernah aktif tapi sekarang mati
    if json_active and json_start_time is not None:
        time_since_json_stop = current_time - json_start_time
        # Jika JSON mati lebih dari first_check ‚Üí NEEDS KILL
        if time_since_json_stop >= first_check_seconds:
            acc["last_status"] = "needs_kill"
            return "needs_kill"
        else:
            # Masih dalam grace period setelah JSON mati
            acc["last_status"] = "in_game"
            return "in_game"
    
    # 4c. Launch sudah lama, JSON belum pernah aktif ‚Üí NEEDS KILL
    if launch_time is not None:
        time_since_launch = current_time - launch_time
        if time_since_launch >= first_check_seconds:
            acc["last_status"] = "needs_kill"
            return "needs_kill"
    
    # 4d. Kondisi tidak jelas ‚Üí WAITING
    acc["last_status"] = "waiting"
    return "waiting"

# =========================
# DISPLAY - TABEL RAPI + LOG ROLLING
# =========================
def display_monitor_screen(pkgs, cfg):
    """
    Display monitor screen dengan format:
    - Header + Tabel
    - 5 baris log terakhir
    """
    clear_screen()
    
    # Header
    print("=" * 80)
    print(" " * 30 + "üéÆ ROBLOX OVA MONITOR")
    print("=" * 80)
    print()
    
    # Tabel Header
    print(f"{'No':<4} {'Username':<16} {'Package':<22} {'Status':<30}")
    print("-" * 80)
    
    # Tabel Content
    all_in_game = True
    for i, (pkg, info) in enumerate(pkgs.items(), 1):
        username = info["username"]
        pkg_short = pkg.split('.')[-1][:20]  # Singkat package name
        
        status = determine_account_status(pkg, info, cfg)
        
        # Format status display
        if status == "in_game":
            time_diff = get_json_time_diff(info, username, cfg)
            if time_diff is not None:
                status_display = f"üü¢ In Game | JSON: {int(time_diff)}s"
            else:
                status_display = "üü¢ In Game"
        elif status == "offline":
            status_display = "‚ö´ Offline"
            all_in_game = False
        elif status == "waiting":
            launch_time = ACCOUNT_STATE[pkg].get("launch_time")
            if launch_time:
                first_check_seconds = cfg["first_check"] * 60
                remaining = max(0, int(first_check_seconds - (time.time() - launch_time)))
                status_display = f"üü° Waiting ({remaining}s)"
            else:
                status_display = "üü° Waiting"
            all_in_game = False
        elif status == "needs_kill":
            status_display = "üî¥ JSON Dead - Killing"
            all_in_game = False
        else:
            status_display = f"‚ùì {status}"
            all_in_game = False
        
        # Potong jika terlalu panjang
        username_display = username[:14] if len(username) <= 14 else username[:13] + "."
        status_display = status_display[:28] if len(status_display) <= 28 else status_display[:27] + "."
        
        print(f"{i:<4} {username_display:<16} {pkg_short:<22} {status_display:<30}")
    
    # Footer
    print("-" * 80)
    timestamp = time.strftime('%H:%M:%S')
    status_text = "‚úÖ ALL IN GAME" if all_in_game else "‚ùå NEEDS ATTENTION"
    print(f"üïí {timestamp} | üì¶ Total: {len(pkgs)} | {status_text}")
    print("=" * 80)
    print()
    
    # Console Log (5 baris terakhir)
    print("üìã CONSOLE LOG:")
    print("-" * 80)
    if LOG_BUFFER:
        for log_line in LOG_BUFFER:
            print(log_line)
    else:
        print("[No logs yet]")
    print("-" * 80)
    print()

# =========================
# SEQUENTIAL STARTUP
# =========================
def sequential_startup(pkgs, cfg):
    """Startup semua package secara sequential"""
    success_count = 0

    add_log("=" * 40)
    add_log("STOPPING ALL EXISTING INSTANCES")
    add_log("=" * 40)

    for pkg, info in pkgs.items():
        if is_app_running(pkg):
            stop_app(pkg)
            # Reset state
            if pkg in ACCOUNT_STATE:
                ACCOUNT_STATE[pkg]["launch_time"] = None
                ACCOUNT_STATE[pkg]["json_start_time"] = None
                ACCOUNT_STATE[pkg]["json_active"] = False

    time.sleep(cfg["restart_delay"] * 2)

    for i, (pkg, info) in enumerate(pkgs.items(), 1):
        username = info["username"]

        add_log(f"Starting {i}/{len(pkgs)}: {username}")

        start_app(pkg, cfg["game_id"])
        
        # Set launch time
        ACCOUNT_STATE.setdefault(pkg, {})
        ACCOUNT_STATE[pkg]["launch_time"] = time.time()
        ACCOUNT_STATE[pkg]["json_active"] = False
        ACCOUNT_STATE[pkg]["json_start_time"] = None
        
        time.sleep(cfg["startup_delay"])

        # Tunggu sampai in_game atau timeout
        max_wait = cfg["first_check"] * 60 + 30  # Grace period + buffer
        start_time = time.time()
        
        while (time.time() - start_time) < max_wait:
            status = determine_account_status(pkg, info, cfg)
            
            if status == "in_game":
                add_log(f"‚úÖ {username} is IN GAME")
                success_count += 1
                break
            elif status == "needs_kill":
                add_log(f"‚ùå {username} FAILED (JSON dead)")
                break
            
            time.sleep(cfg["workspace_check_interval"])
        else:
            add_log(f"‚è±Ô∏è {username} TIMEOUT waiting")

        if i < len(pkgs):
            time.sleep(3)

    add_log("=" * 40)
    add_log(f"üìä RESULTS: {success_count}/{len(pkgs)} accounts in game")
    add_log("=" * 40)

    return success_count

# =========================
# MONITOR LOOP
# =========================
def monitor():
    """Main monitor loop"""
    global monitor_active

    cfg = load_config()
    pkgs = load_packages()

    if not cfg["game_id"]:
        add_log("Game ID not set")
        input("Enter...")
        return

    if not pkgs:
        add_log("No packages found")
        input("Enter...")
        return

    monitor_active = True

    # Sequential startup
    add_log("STARTING SEQUENTIAL STARTUP")
    time.sleep(2)

    online_count = sequential_startup(pkgs, cfg)

    if online_count == 0:
        add_log("No accounts went online")
        input("Enter...")
        return

    add_log(f"{online_count} accounts online, starting monitor...")
    time.sleep(3)

    # Webhook startup jika enabled
    if cfg.get("webhook_enabled") and cfg.get("webhook_url"):
        message = build_webhook_status_message(pkgs, cfg)
        send_discord_webhook(
            cfg["webhook_url"],
            "üöÄ Monitor Started",
            message,
            3066993
        )

    try:
        cycle_count = 0
        last_webhook_time = time.time()
        last_restart_time = time.time()
        
        while monitor_active:
            cycle_count += 1
            
            # Display tabel
            display_monitor_screen(pkgs, cfg)
            
            # Monitor dan handle status
            for pkg, info in pkgs.items():
                username = info["username"]
                status = determine_account_status(pkg, info, cfg)
                
                # HANYA handle status yang perlu action
                if status == "needs_kill":
                    add_log(f"üî¥ {username}: JSON DEAD ‚Üí KILLING & RESTART")
                    stop_app(pkg)
                    time.sleep(cfg["restart_delay"])
                    
                    # Reset state
                    ACCOUNT_STATE[pkg]["launch_time"] = time.time()
                    ACCOUNT_STATE[pkg]["json_start_time"] = None
                    ACCOUNT_STATE[pkg]["json_active"] = False
                    
                    # Launch ulang
                    start_app(pkg, cfg["game_id"])
                    time.sleep(cfg["startup_delay"])
                
                elif status == "offline":
                    add_log(f"‚ö´ {username}: OFFLINE ‚Üí LAUNCHING")
                    
                    # Reset state
                    ACCOUNT_STATE[pkg]["launch_time"] = time.time()
                    ACCOUNT_STATE[pkg]["json_start_time"] = None
                    ACCOUNT_STATE[pkg]["json_active"] = False
                    
                    # Launch
                    start_app(pkg, cfg["game_id"])
                    time.sleep(cfg["startup_delay"])
            
            # Webhook interval
            current_time = time.time()
            webhook_interval_seconds = cfg.get("webhook_interval", 10) * 60
            
            if cfg.get("webhook_enabled", False) and cfg.get("webhook_url", ""):
                if (current_time - last_webhook_time) >= webhook_interval_seconds:
                    message = build_webhook_status_message(pkgs, cfg)
                    send_discord_webhook(
                        cfg["webhook_url"],
                        "üìä Status Update",
                        message,
                        3447003
                    )
                    last_webhook_time = current_time
                    add_log("üì° Webhook sent")
            
            # Restart interval
            restart_interval_seconds = cfg.get("restart_interval", 0) * 60
            if restart_interval_seconds > 0:
                if (current_time - last_restart_time) >= restart_interval_seconds:
                    add_log("‚è∞ Auto restart time reached")
                    
                    if cfg.get("webhook_enabled", False) and cfg.get("webhook_url", ""):
                        send_discord_webhook(
                            cfg["webhook_url"],
                            "üîÑ Auto Restart",
                            "Restarting all Roblox packages...",
                            16776960
                        )
                    
                    restart_all_roblox(pkgs, cfg)
                    last_restart_time = current_time
            
            time.sleep(cfg["check_interval"])
    
    except Exception as e:
        add_log(f"Monitor error: {e}")
        
        if cfg.get("webhook_enabled", False) and cfg.get("webhook_url", ""):
            send_discord_webhook(
                cfg["webhook_url"],
                "‚ùå Monitor Error",
                f"Error occurred: {str(e)}",
                16711680
            )
        
        input("Press ENTER...")
    finally:
        monitor_active = False

def restart_all_roblox(pkgs, cfg):
    """Restart semua Roblox package"""
    add_log("=" * 40)
    add_log("RESTARTING ALL ROBLOX PACKAGES")
    add_log("=" * 40)
    
    # Stop semua
    for pkg, info in pkgs.items():
        if is_app_running(pkg):
            add_log(f"Stopping {info['username']}")
            stop_app(pkg)
    
    add_log("Waiting before restart...")
    time.sleep(cfg["restart_delay"] * 2)
    
    # Start semua sequential
    return sequential_startup(pkgs, cfg)

# =========================
# MENU
# =========================
def menu():
    """Main menu"""
    while True:
        clear_screen()
        cfg = load_config()
        pkgs = load_packages()
        
        print("=" * 70)
        print("ü§ñ ROBLOX MULTI-PACKAGE MANAGER (Termux/Cloudphone) v2")
        print("=" * 70)
        print(f"üéÆ Game ID      : {cfg.get('game_id', 'Not set')}")
        print(f"üì¶ Packages     : {len(pkgs)}")
        print(f"‚è±Ô∏è First Check  : {cfg.get('first_check', 3)} minutes")
        
        # Webhook info
        webhook_status = "‚úÖ" if cfg.get("webhook_enabled", False) else "‚ùå"
        print(f"üì° Webhook      : {webhook_status}")
        if cfg.get("webhook_url", ""):
            webhook_display = cfg["webhook_url"][:40] + "..." if len(cfg["webhook_url"]) > 40 else cfg["webhook_url"]
            print(f"   URL          : {webhook_display}")
            print(f"   Interval     : {cfg.get('webhook_interval', 10)} minutes")
            restart_text = f"{cfg.get('restart_interval', 0)} minutes" if cfg.get('restart_interval', 0) > 0 else "Disabled"
            print(f"   Auto Restart : {restart_text}")
        
        if pkgs:
            print("\nüìã Registered Packages:")
            for i, (pkg, info) in enumerate(pkgs.items(), 1):
                cache_dir = find_cache_dir(pkg)
                cache_status = "‚úÖ" if cache_dir else "‚ùå"
                scripts_count = len(list_executor_scripts(info))
                print(f"  {i}. {info['username']} (üóÇÔ∏è:{cache_status} üìú:{scripts_count})")
        
        print("=" * 70)
        print("1. üöÄ Start Monitor (All Packages)")
        print("2. ‚öôÔ∏è Set Game ID")
        print("3. üîç Auto Detect Packages")
        print("4. üì° Configure Webhook")
        print("5. ‚è±Ô∏è Set First Check Time")
        print("-" * 40)
        print("6. üìù Add Script to ALL Packages")
        print("7. üóëÔ∏è Delete Script from ALL Packages")
        print("8. üëÅÔ∏è View Scripts in ALL Packages")
        print("-" * 40)
        print("9. üóÇÔ∏è Copy ALL Cache Files to ALL Packages")
        print("10. üìä View Cache Folder Status")
        print("-" * 40)
        print("0. ‚ùå Exit\n")
        
        c = input("üìå Select: ").strip()
        
        if c == "1": 
            monitor()
        elif c == "2":
            cfg["game_id"] = input("üéÆ Game ID: ").strip()
            save_config(cfg)
            input("Enter...")
        elif c == "3": 
            auto_detect_and_save_packages()
        elif c == "4":
            # Configure webhook
            clear_screen()
            print("=" * 70)
            print("üì° WEBHOOK CONFIGURATION")
            print("=" * 70)
            
            webhook_url = input("üîó Discord webhook URL (Enter to skip): ").strip()
            if webhook_url:
                cfg["webhook_url"] = webhook_url
            
            enable = input("üì° Enable webhook? (y/n, default=y): ").strip().lower()
            cfg["webhook_enabled"] = (enable == "" or enable == "y")
            
            interval = input("‚è±Ô∏è Webhook interval in minutes (default=10): ").strip()
            if interval:
                try:
                    cfg["webhook_interval"] = int(interval)
                except:
                    cfg["webhook_interval"] = 10
            
            restart = input("üîÑ Restart interval in minutes (0=disabled, default=0): ").strip()
            if restart:
                try:
                    cfg["restart_interval"] = int(restart)
                except:
                    cfg["restart_interval"] = 0
            
            save_config(cfg)
            add_log("‚úÖ Webhook configuration saved")
            input("\nPress ENTER...")
        elif c == "5":
            clear_screen()
            print("=" * 70)
            print("‚è±Ô∏è FIRST CHECK CONFIGURATION")
            print("=" * 70)
            print("First check adalah grace period sebelum kill akun.")
            print("Jika JSON tidak aktif setelah grace period, akun akan di-kill.\n")
            
            current = cfg.get("first_check", 3)
            print(f"Current: {current} minutes\n")
            
            new_time = input("‚è±Ô∏è New first check time in minutes (default=3): ").strip()
            if new_time:
                try:
                    cfg["first_check"] = int(new_time)
                    save_config(cfg)
                    add_log(f"‚úÖ First check set to {cfg['first_check']} minutes")
                except:
                    add_log("‚ùå Invalid input")
            
            input("\nPress ENTER...")
        elif c == "6":
            add_script_to_all_packages()
        elif c == "7":
            delete_script_from_all_packages()
        elif c == "8":
            view_scripts_all_packages()
        elif c == "9":
            copy_license_to_all_packages()
        elif c == "10":
            view_license_status()
        elif c == "0": 
            break

# =========================
# MAIN
# =========================
if __name__ == "__main__":
    menu()
